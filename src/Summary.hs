{-# LANGUAGE RecordWildCards #-}

module Summary (summary) where

import Control.Monad
import Data.Foldable
import Data.List.Extra
import Data.Map (Map)
import qualified Data.Map as Map
import System.FilePath

import Apply
import Config.Type
import CmdLine
import GHC.All
import Hint.All
import Idea
import Test.Annotations
import Test.Util

import Paths

-- | A map from (hint name, hint severity, does hint support refactoring) to an example.
type BuiltinSummary = Map (String, Severity, Bool) BuiltinEx

data BuiltinEx = BuiltinEx
    { builtinInp :: !String
    , builtinFrom :: !String
    , builtinTo :: !(Maybe String)
    }

-- | Generate a summary of hints, including built-in hints and YAML-configured hints
-- from @data/hlint.yaml@ and user-supplied YAML files.
summary :: Cmd -> [Setting] -> IO ()
summary cmd settings = do
    builtinHints <- mkBuiltinSummary settings
    let lhsRhsHints = [hint | SettingMatchExp hint <- settings]
    putStrLn $ "\nWriting to " ++ cmdOutput cmd
    writeFile (cmdOutput cmd) (genBuiltinSummaryMd builtinHints lhsRhsHints)

-- | The summary of built-in hints is generated by running the test cases in
-- @src/Hint/*.hs@. One entry per (hint name, severity, does it support refactoring).
mkBuiltinSummary :: [Setting] -> IO BuiltinSummary
mkBuiltinSummary settings = foldM f Map.empty builtinHints
  where
    f :: BuiltinSummary -> (String, Hint) -> IO BuiltinSummary
    f summ (name, hint) = do
        progress
        file <- getDataFileName $ "src/Hint" </> name <.> "hs"
        tests <- parseTestFile file
        foldM (g file) summ tests

    g :: FilePath -> BuiltinSummary -> TestCase -> IO BuiltinSummary
    g file summ (TestCase _ _ inp _ _) = do
        ideas <- applyHintFile defaultParseFlags settings file (Just inp)
        pure $ foldl' (addIdea inp) summ ideas

    addIdea :: String -> BuiltinSummary -> Idea -> BuiltinSummary
    addIdea inp summ Idea{..}
      | "Parse error" `isPrefixOf` ideaHint = summ
      | otherwise =
            let k = (ideaHint, ideaSeverity, notNull ideaRefactoring)
                v = BuiltinEx inp ideaFrom ideaTo
            -- Do not insert if the key already exists in the map. This has the effect
            -- of picking the first test case of a hint as the example in the summary.
            in Map.insertWith (curry snd) k v summ

genBuiltinSummaryMd :: BuiltinSummary -> [HintRule] -> String
genBuiltinSummaryMd builtins lhsRhs = unlines $
  [ "# Summary of Hints"
  , ""
  , "This page is auto-generated from `hlint summary hints.md --no-implicit`."
  , ""
  , "## Built-in Hints"
  , ""
  ]
  ++ builtinTable builtins
  ++
  [ ""
  , "## LHS/RHS hints"
  , ""
  ]
  ++ lhsRhsTable lhsRhs

row :: [String] -> [String]
row xs = ["<tr>"] ++ xs ++ ["</tr>"]

-- | Render using <code> if it is single-line, otherwise using <pre>.
haskell :: String -> [String]
haskell s
  | '\n' `elem` s = ["<pre>", s, "</pre>"]
  | otherwise = ["<code>", s, "</code>", "<br>"]

builtinTable :: BuiltinSummary -> [String]
builtinTable builtins =
  ["<table>"]
  ++ row ["<th>Hint Name</th>", "<th>Severity</th>", "<th>Support Refactoring?</th>"]
  ++ Map.foldMapWithKey showBuiltin builtins
  ++ ["</table>"]

showBuiltin :: (String, Severity, Bool) -> BuiltinEx -> [String]
showBuiltin (hint, sev, refact) BuiltinEx{..} = row1 ++ row2
  where
    row1 = row
      [ "<td rowspan=2>" ++ hint ++ "</td>"
      , "<td>" ++ show sev ++ "</td>"
      , "<td>" ++ if refact then "Yes" else "No" ++ "</td>"
      ]
    row2 = row example
    example =
      [ "<td colspan=2>"
      , "Example:"
      ]
      ++ haskell builtinInp
      ++ ["Found:"]
      ++ haskell builtinFrom
      ++ ["Suggestion:"]
      ++ haskell to
      ++ ["</td>"]
    to = case builtinTo of
      Nothing -> ""
      Just "" -> "Perhaps you should remove it."
      Just s -> s

lhsRhsTable :: [HintRule] -> [String]
lhsRhsTable hints =
  ["<table>"]
  ++ row ["<th>Hint Name</th>", "<th>Hint</th>", "<th>Severity</th>"]
  ++ concatMap showLhsRhs hints
  ++ ["</table>"]

showLhsRhs :: HintRule -> [String]
showLhsRhs HintRule{..} = row $
  [ "<td>" ++ hintRuleName ++ "</td>"
  , "<td>"
  , "LHS:"
  ]
  ++ haskell (show hintRuleLHS)
  ++ ["RHS:"]
  ++ haskell (show hintRuleRHS)
  ++
  [ "</td>"
  , "<td>" ++ show hintRuleSeverity ++ "</td>"
  ]
